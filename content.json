{"meta":{"title":"Yang Chen's Blog","subtitle":null,"description":null,"author":"杨晨","url":"http://yoursite.com"},"pages":[{"title":"归档","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-14T11:48:19.198Z","comments":false,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-17T10:58:45.663Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我Hi，我是杨晨，一个菜鸟级Android工程师，目前就读于浙江大学软件学院，是一名研一的学生，对Android开发情有独钟，立志成为一名高级Android开发工程师。 关于本博客 2017.12.14：使用Hexo+GitHub创建本博客，使用的是NexT主题，评论系统采用来必力。"},{"title":"所有分类","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-14T09:59:01.154Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-14T10:01:18.349Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BroadcastReceiver基础知识","slug":"android-broadcast","date":"2018-01-15T01:56:00.000Z","updated":"2018-01-15T01:57:33.661Z","comments":true,"path":"2018/01/15/android-broadcast/","link":"","permalink":"http://yoursite.com/2018/01/15/android-broadcast/","excerpt":"什么是广播在Android中，广播是一种广泛运用的在应用程序之间传输信息的机制，Android中我们要发送的广播内容是一个Intent，这个Intent中可以携带我们要传送的数据。比如我们可以使用广播来实现Activity与Service之间的通信，而不必使用bindService；还有一个常用的场景就是当我们在应用中退出登录后，需要调到登录界面，而之前的主界面可以发送一个广播来通知主界面销毁自己。","text":"什么是广播在Android中，广播是一种广泛运用的在应用程序之间传输信息的机制，Android中我们要发送的广播内容是一个Intent，这个Intent中可以携带我们要传送的数据。比如我们可以使用广播来实现Activity与Service之间的通信，而不必使用bindService；还有一个常用的场景就是当我们在应用中退出登录后，需要调到登录界面，而之前的主界面可以发送一个广播来通知主界面销毁自己。 广播的种类广播一共有以下3种类型： Normal Broadcast：普通广播，调用方法是Context.sendBroadcast System Broadcast：系统广播（开机、电量低），调用方法是Context.sendOrderedBroadcast Local Broadcast：本地广播，只在自身APP内传播，内部实现机制是Handler 广播的使用场景 同一个App具有多个进程的不同组件之间的消息通信，定位服务一般都会在一个单独的进程中，通过广播告诉其他进程定位信息 不同app之间的组件之间的消息通信，比如系统电话 实现广播实现广播有两种方式： 静态注册：在AndroidManifest.xml里通过标签声明 12345678910111213141516171819202122&lt;receiver android:enabled=[\"true\" | \"false\"]//此broadcastReceiver能否接收其他App的发出的广播//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false android:exported=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:label=\"string resource\"//继承BroadcastReceiver子类的类名 android:name=\".mBroadcastReceiver\"//具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收； android:permission=\"string\"//BroadcastReceiver运行所处的进程//默认为app的进程，可以指定独立的进程//注：Android四大基本组件都可以通过此属性指定自己的独立进程 android:process=\"string\" &gt;//用于指定此广播接收器将接收的广播类型//本示例中给出的是用于接收网络状态改变时发出的广播 &lt;intent-filter&gt;&lt;action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 创建一个类继承自BroadcastReciver，然后复写其中的onReceive()方法，判断相应的action即可。静态注册的广播会一直存在，不管app是否是运行的，只要接收到注册的广播就会执行onRecive里的代码。 动态注册： 需要在activity中动态的registerReceiver 12345678910111213141516171819202122232425262728// 选择在Activity生命周期方法中的onResume()中注册@Override protected void onResume()&#123; super.onResume(); // 1. 实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver mBroadcastReceiver = new mBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); // 2. 设置接收广播的类型 intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE); // 3. 动态注册：调用Context的registerReceiver（）方法 registerReceiver(mBroadcastReceiver, intentFilter); &#125;// 注册广播后，要在相应位置记得销毁广播// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)// 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中// 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。 @Override protected void onPause() &#123; super.onPause(); //销毁在onResume()方法中的广播 unregisterReceiver(mBroadcastReceiver); &#125;&#125; 相比于静态注册，动态注册的广播跟随着activity的生命周期，同时为了防止内存溢出，需要在activity的onDestory方法中调用unregisterReceiver(mBroadcastReceiver); 广播的内部实现机制 自定义广播接收者BroadcastReceiver，并复写onReceive()方法 通过Binder机制向AMS(Activity Manager Service)进行注册 广播发送者通过Binder机制向AMS发送广播 AMS查找符合相应条件的BroadcastReceiver，将广播发送到BroadcastReceiver相应的消息循环队列中 消息循环执行拿到此广播，回调BroadcastReceiver中的onReceiver方法本地广播的优点 使用它发送的广播将只在自身app内传播，因此你不必担心泄漏隐私数据 其他App无法对你的app发送广播，因为你的app根本就不可能接收到非自身应用发送的该广播，因此不必担心有安全漏洞可以利用 它比系统广播更加高效LocalBroadcastManager源码分析首先我们看源码要有目的的去看，而且入口点是你调用的方法，从该方法去看这里的入口就是registerReceiver12345678910111213141516171819202122public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; synchronized (mReceivers) &#123; //保存的是filter和receiver ReceiverRecord entry = new ReceiverRecord(filter, receiver); ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.get(receiver); if (filters == null) &#123; filters = new ArrayList&lt;&gt;(1); mReceivers.put(receiver, filters); &#125; filters.add(entry); for (int i=0; i&lt;filter.countActions(); i++) &#123; String action = filter.getAction(i); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) &#123; entries = new ArrayList&lt;ReceiverRecord&gt;(1); mActions.put(action, entries); &#125; entries.add(entry); &#125; &#125; &#125; 再来看发送广播的方法，这里只截取的关键的一部分 12345678910if (receivers != null) &#123; for (int i=0; i&lt;receivers.size(); i++) &#123; receivers.get(i).broadcasting = false; &#125; mPendingBroadcasts.add(new BroadcastRecord(intent, receivers)); if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123; mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); &#125; return true; &#125; 可以看到它内部是使用Handler来发送的，这就说明了它比系统广播更加的高效。","categories":[{"name":"Android基础知识","slug":"Android基础知识","permalink":"http://yoursite.com/categories/Android基础知识/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"BroadcastReceiver","slug":"BroadcastReceiver","permalink":"http://yoursite.com/tags/BroadcastReceiver/"}]},{"title":"Service基础知识","slug":"android-service","date":"2018-01-14T06:56:00.000Z","updated":"2018-01-14T06:58:58.824Z","comments":true,"path":"2018/01/14/android-service/","link":"","permalink":"http://yoursite.com/2018/01/14/android-service/","excerpt":"Service是什么？Service是一个一种能够长时间在后台运行并没有用户界面的应用组件。","text":"Service是什么？Service是一个一种能够长时间在后台运行并没有用户界面的应用组件。 Service和Thread的区别Service翻译成中文就是“服务”，也许有人会认为服务就是能在后台执行耗时操作的，那就大错特错了，Service是运行在主线程的，如果超过20秒还未处理完成则Android系统就会报ANR错误，即应用未响应。 下面我们来验证一下，首先在Android Studio中创建一个MainActivity，再创建一个Service，在MainActivity中启动Service，并打印它们各自的所在的线程。 1234567891011121314151617181920212223242526272829public class MainActivity extends BaseActivity &#123; private static final String TAG = \"MainActivity\"; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Override protected void setContentView() &#123; setContentView(R.layout.activity_main); //这里打印所在线程 Log.d(TAG, \"Thread is\" + Thread.currentThread().getName()); &#125; @Override protected void initView() &#123; &#125; @Override protected void initData() &#123; Intent intent = new Intent(MainActivity.this,MyService.class); startService(intent); &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class MyService extends Service &#123; private static final String TAG = \"MyService\"; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(\"Not yet implemented\"); &#125; @Override public void onCreate() &#123; super.onCreate(); //这里打印所在线程 Log.d(TAG, \"Thread is\" + Thread.currentThread().getName()); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125; @Override public boolean onUnbind(Intent intent) &#123; return super.onUnbind(intent); &#125;&#125; 运行后的结果如下图。 可以看出Service确实是运行在主线程中的，那么我们就不应该在Service中执行耗时的操作了，应该在子线程中执行耗时的操作。 Service的启动方式Service一共有两种启动方式，一个是startService，另一个是bindService startService方法启动这种方式启动service比较简单和启动一个activity差不多，步骤如下： 创建一个service，并在AndroidManifest文件中进行注册（使用Android Studio自动生成的可忽略） 在Activity中创建`Intent intent = new Intent(MainActivity.this,MyService.class);startService(intent);` 具体代码如下： 1234567891011121314151617181920212223242526272829public class MainActivity extends BaseActivity &#123; private static final String TAG = \"MainActivity\"; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Override protected void setContentView() &#123; setContentView(R.layout.activity_main); Log.d(TAG, \"Thread is \" + Thread.currentThread().getName()); &#125; @Override protected void initView() &#123; &#125; @Override protected void initData() &#123; //启动服务 Intent intent = new Intent(MainActivity.this,MyService.class); startService(intent); &#125;&#125; 启动服务后依次会调用service中的onCreate-&gt;onStartCommand方法，其中onCreate只会调用一次，如果重新启动service的话，会重新调用onStartCommand方法。 onStartCommand方法的返回值onStartCommand是有返回值的，返回值类型为int 1234@Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; 通过看源码可以发现返回值有两个类型，分别是START_STICKY_COMPATIBILITY和START_STICKY START_STICKY_COMPATIBILITY：如果返回该值则不保证服务被杀死后会重新启动。 START_STICKY：如果返回该值则服务在启动后被杀死会重新启动，会重新调用onStartCommand方法。 1234public @StartResult int onStartCommand(Intent intent, @StartArgFlags int flags, int startId) &#123; onStart(intent, startId); return mStartCompatibility ? START_STICKY_COMPATIBILITY : START_STICKY; &#125; 默认返回的是START_STICKY。 在service内部给activity创建启动服务的方法在看Tinker的源码过程中发现，可以在service内部给activity创建启动服务的方法，代码如下，这样的好处就是提高了代码的封装性。 123456789//对外提供启动servcie方法 public static void runService(Context context) &#123; try &#123; Intent intent = new Intent(context, MyService.class); context.startService(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; bindService方法启动bindService启动的service会将service与activity绑定，activity销毁了service也就停止了，步骤如下： 创建BindService服务端，继承自Service类，并在类中创建一个实现IBinder接口的实例对象并提供公共方法给客户端来调用。 从onBind方法回调方法返回此Binder实例 在客户端中，从onServiceConnected回调方法接收Binder，并使用提供的方法调用绑定服务。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class MyService extends Service &#123; private static final String TAG = \"MyService\"; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // 返回IBinder对象 return new MyBinder(); &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, \"Thread is \" + Thread.currentThread().getName()); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125; @Override public boolean onUnbind(Intent intent) &#123; return super.onUnbind(intent); &#125; //给客户端提供服务的实例，从而可以来调用服务里的方法 public class MyBinder extends Binder &#123; public MyService getService()&#123; return MyService.this; &#125; &#125; public void execute()&#123; Log.d(TAG, \"activity 调用 service 里的方法成功\"); &#125;&#125;public class MainActivity extends BaseActivity &#123; private static final String TAG = \"MainActivity\"; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Override protected void setContentView() &#123; setContentView(R.layout.activity_main); Log.d(TAG, \"Thread is \" + Thread.currentThread().getName()); &#125; @Override protected void initView() &#123; &#125; @Override protected void initData() &#123; Intent intent = new Intent(MainActivity.this,MyService.class); //绑定服务 bindService(intent,serviceConnection,BIND_AUTO_CREATE); &#125; ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //服务连接成功调用 Log.d(TAG, \"service 连接成功\"); MyService myService = ((MyService.MyBinder)service).getService(); myService.execute(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; //服务断开连接调用 &#125; &#125;;&#125; 运行结果如下图。 bindService执行的服务里方法的顺序如下： onCreate-&gt;onBind-&gt;(Activity)onServiceConnected通过绑定服务我们可以完成activity和service之间的通信，当然也可以使用广播。","categories":[{"name":"Android基础知识","slug":"Android基础知识","permalink":"http://yoursite.com/categories/Android基础知识/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Service","slug":"Service","permalink":"http://yoursite.com/tags/Service/"}]},{"title":"模板模式在Android开发中的应用","slug":"Template-Pattern","date":"2018-01-14T02:28:00.000Z","updated":"2018-01-14T04:13:45.406Z","comments":true,"path":"2018/01/14/Template-Pattern/","link":"","permalink":"http://yoursite.com/2018/01/14/Template-Pattern/","excerpt":"对模板模式理解模板模式就是定义一个抽象类，在这个抽象类中定义一些能被子类重写的抽象方法，同时定义一个不能被子类重写，按一定顺序执行的算法，子类不能改变这个执行顺序，但是可以根据自己的需求对其中的方法进行重写。","text":"对模板模式理解模板模式就是定义一个抽象类，在这个抽象类中定义一些能被子类重写的抽象方法，同时定义一个不能被子类重写，按一定顺序执行的算法，子类不能改变这个执行顺序，但是可以根据自己的需求对其中的方法进行重写。 例如电脑从开机到关机要经过： 开机-&gt;操作电脑-&gt;关机 我们不能改变这个顺序，但可以对电脑的不同操作。 对模板模式的一般例子可以参考：https://www.cnblogs.com/qq-361807535/p/6854191.html 下面我主要说的是模板模式在Android开发中的具体应用，我们都知道在开发中我们都要写一个Activity的基类，主要抽象了一些我们在写Activity时都会用到的方法。 比如，加载布局、初始化View、初始化一些数据等等。 12345678910111213141516171819202122public abstract class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(); initView(); initData(); &#125; /** * 设置布局 */ protected abstract void setContentView(); /** * 初始化View */ protected abstract void initView(); /** * 初始化数据 */ protected abstract void initData();&#125; 在BaseActivity中定义了3个抽象方法。 setContentView：设置布局，需要子类来实现 initView：初始化View，需要子类实现 initData：初始化数据，需要子类实现而在子类中不需要重写onCreate方法，只需要实现上面的3个方法即可，还有就是如果使用了ButterKnife的话，也只是需要在onCreate加入ButterKnife.bind(this);，在子类中就可以使用ButterKnife了。 具体子类的代码如下： 1234567891011121314151617181920public class MainActivity extends BaseActivity &#123; @Override protected void setContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; &#125; @Override protected void initData() &#123; &#125;&#125; 模板模式在Android开发中的应用就到此结束了。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://yoursite.com/tags/Design-Pattern/"}]},{"title":"Fragment基础知识","slug":"android-fragment","date":"2018-01-13T04:02:00.000Z","updated":"2018-01-13T04:05:25.986Z","comments":true,"path":"2018/01/13/android-fragment/","link":"","permalink":"http://yoursite.com/2018/01/13/android-fragment/","excerpt":"为什么说Fragment是Android中的第五大组件Fragment是在Android 3.0之后提出来的，目的是为了解决平板上的显示效果，如下图所示。 从目前的Android应用的架构来说，主流使用的是多Activity+多Fragment这种模式，即一个Activity管理多个Fragment，比如说一个Activity管理登录、注册和忘记密码这几个Fragment。由此可以看出Fragment的使用频率已经不低于Activity了，并且Fragment具有更低的内存消耗，页面间的切换也更加的流畅。还有一个原因就是Fragment拥有自己的生命周期，不过它必须依附于Activity。","text":"为什么说Fragment是Android中的第五大组件Fragment是在Android 3.0之后提出来的，目的是为了解决平板上的显示效果，如下图所示。 从目前的Android应用的架构来说，主流使用的是多Activity+多Fragment这种模式，即一个Activity管理多个Fragment，比如说一个Activity管理登录、注册和忘记密码这几个Fragment。由此可以看出Fragment的使用频率已经不低于Activity了，并且Fragment具有更低的内存消耗，页面间的切换也更加的流畅。还有一个原因就是Fragment拥有自己的生命周期，不过它必须依附于Activity。 Fragment的两种创建方式 直接把Fragment写在布局中，把它当做一个控件来使用，这里需要为fragment标签绑定Fragment，即填写name属性即可 12345&lt;fragment android:id=\"@+id/id_fragment_title\" android:name=\"com.yangc.fragments.TitleFragment\" android:layout_width=\"fill_parent\" android:layout_height=\"45dp\" /&gt; 使用FragmentManager来动态的增删 1234567891011121314151617181920212223242526动态的增删需要为Fragment指定一个布局容器来填充，如FrameLayout、RelativeLayout等 FragmentManager fm = getFragmentManager(); // 开启Fragment事务 FragmentTransaction transaction = fm.beginTransaction(); switch (v.getId()) &#123; case R.id.tab_bottom_weixin: if (mWeixin == null) &#123; mWeixin = new ContentFragment(); &#125; // 使用当前Fragment的布局替代id_content的控件 transaction.replace(R.id.id_content, mWeixin); break; case R.id.tab_bottom_friend: if (mFriend == null) &#123; mFriend = new FriendFragment(); &#125; transaction.replace(R.id.id_content, mFriend); break; &#125; // 事务提交 transaction.commit(); &#125; 这里需要注意的是FragmentTransaction transaction = fm.beginTransaction();和transaction.commit();需要成对的使用。 FragmentPageAdapter和FragmentStatePageAdapter的区别 通常Fragment会和ViewPager一起配合着使用，来实现左右滑动切换页面的效果。 FragmentPageAdapter使用在页面比较少的情况下，而FragmentStatePageAdapter使用在页面比较多的情况下，从源码中可以发现，FragmentPageAdapter在销毁每个item时是使用detach()方法，这个方法仅仅只是在UI层面上将Fragment进行脱离并没有销毁这个item，如下图所示。 而FragmentStatePageAdapter在销毁每个item时使用的是remove()方法，这个方法会销毁这个item，如下图所示，所以FragmentStatePageAdapter对内存更友好。 Fragment的生命周期Fragment的生命周期是依赖于Activity的，它不能单独存在，下图是其生命周期。 下面来对Fragment的生命周期和Activity的生命周期一起进行分析，如下图所示。 创建Fragment调用onAttach()方法，将Fragment与Activity进行关联，再调用onCreate()方法，调用onCreateView()方法，这个方法就是返回我们自己布局的，注意要返回根布局，View创建好后会调用onViewCreated()方法，再是Activity的onCreate()方法，启动Activity后会调用onActivityCreated方法，在是Activity的onStart方法，Fragment的onStart方法，Activity的onResume方法，Fragment的onResume()，到此Fragment已经可见并可以交互了。 Fragment的通信有以下三种方式： 在Fragment中调用Activity中的方法使用getActivity()，获取其宿主Activity 在Activity中调用Fragment中的方法，需要在Fragment定义接口，在Activity中实现这个接口，即接口回调 在Fragment中调用另一个Fragment中的方法，使用getActivity方法获取到宿主Activity，在调用Activity中的findFragmentById方法获取另一个Fragment。 Fragment的切换 replace：移除掉（实例会被回收掉）栈中的其他所有Fragment，并将当前Fragment添加到栈中，这种方式会使栈中仅有一个Fragment，并且每次都会新建Fragment实例。 add&amp;remove：add会在栈中创建一个Fragment实例，而remove会销毁一个Fragment。 hide&amp;show：把前面的Fragment隐藏掉了，把新的Fragment添加到栈中，并不会销毁之前的Fragment，不过这种方式会销毁比较多的内存，是开发中最常用的方式。 attach&amp;detach：attach会重绘制View，detach不会销毁Fragment实例，而是销毁其View，这种方式比较鸡肋，开发中不常用。","categories":[{"name":"Android基础知识","slug":"Android基础知识","permalink":"http://yoursite.com/categories/Android基础知识/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://yoursite.com/tags/Fragment/"}]},{"title":"Activity基础知识","slug":"android-activity","date":"2018-01-13T01:48:00.000Z","updated":"2018-01-13T01:53:29.129Z","comments":true,"path":"2018/01/13/android-activity/","link":"","permalink":"http://yoursite.com/2018/01/13/android-activity/","excerpt":"Activity是什么？通俗点说Activity就是能与用户进行交互的界面，如点击、长按、上拉下滑等等。 Activity的4中状态 running：运行状态，位于前台可与用户进行交互 paused：暂停状态，可见但不可与用户进行交互 stopped：停止状态，位于后台不可见 killed：被杀死状态，被回收","text":"Activity是什么？通俗点说Activity就是能与用户进行交互的界面，如点击、长按、上拉下滑等等。 Activity的4中状态 running：运行状态，位于前台可与用户进行交互 paused：暂停状态，可见但不可与用户进行交互 stopped：停止状态，位于后台不可见 killed：被杀死状态，被回收 Activity的生命周期下面是官网的一张图，有个大致的映像即可。 主要说下面的几种情况： 1. Activity启动 &gt; onCreate()-&gt;onStart()-&gt;onResume() 2. 用户按下HOME键 &gt; onPause()-&gt;onStop() 3. 重新打开之前的Activity &gt; onRestart()-&gt;onStart()-&gt;onResume() 4. 正常退出当前Activity &gt; onPause()-&gt;onStop()-&gt;onDestroy() Android进程的优先级我们都知道在内存不足的时候系统会回收优先级低的进程。 前台-&gt;可见-&gt;服务-&gt;后台-&gt;空 前台：用户看得见并且可以交互 可见：用户看到见但不可交互，举个简单的例子就是有个透明的Activity覆盖住了之前的Activity，那么之前的Activity就从前台转到了后台 服务：就是在后台一直运行的services 后台：与服务不同的是后台是由前台转换过来的，按下home键后之前的Activity就处于后台了 空：优先级最低，不属于以上的类型，Android系统可随时杀掉该进程Android的任务栈在Android中，Activity是存在于任务栈中，任务栈是一种栈结构，存放Activity的集合，如下图所示，是一种先进后出的结构。 Activity在一定情况下可以单独占用一个任务栈，这里涉及到Activity的启动模式（后面再说）。 Activity的启动模式Activity的启动模式一共分为4种 standard：默认的是这个模式，每次创建一个Activity时都会新建一个实例，它不管任务栈中是否存在该实例，这样模式会消耗比较大的内存。 singleTop：又叫做栈顶复用模式，每次创建一个新的Activity时都会在任务栈顶查看是否有该实例，如果有则复用，没有才创建。 singleTask：该模式会一直复用任务栈中Activity实例，需要注意的是它会清除它之上的Activity从而是自己到达栈顶，用的比较多的地方就是一个应用的主页。 singleInstance：该模式下创建Activity时会为这个Activity单独创建一个任务栈，用的比较多的一个场景是消息推送，用户点击通知栏上的消息进入到一个Activity中，当用户按下返回键时会之间退出这个应用，而不是进入到这个应用中，因为这个任务栈中只有这个Activity。","categories":[{"name":"Android基础知识","slug":"Android基础知识","permalink":"http://yoursite.com/categories/Android基础知识/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"http://yoursite.com/tags/Activity/"}]},{"title":"使用TestNG和Appium进行Android自动化测试(二)","slug":"android-automated-test-by-testng-appium-two","date":"2017-12-19T09:56:20.000Z","updated":"2017-12-19T12:23:11.870Z","comments":true,"path":"2017/12/19/android-automated-test-by-testng-appium-two/","link":"","permalink":"http://yoursite.com/2017/12/19/android-automated-test-by-testng-appium-two/","excerpt":"前言 看过了上一篇使用TestNG和Appium进行Android自动化测试(一)，相信你已经把所需要的资源都准备好了，接下来就来看看如何使用TestNG和Appium进行Android的自动化测试。","text":"前言 看过了上一篇使用TestNG和Appium进行Android自动化测试(一)，相信你已经把所需要的资源都准备好了，接下来就来看看如何使用TestNG和Appium进行Android的自动化测试。 eclipse项目的配置导入jar/zip 创建一个Java Project(File-&gt;New-&gt;Java Project) 导入（右键项目-&gt;Build Path-&gt;Configure Build Path-&gt;Libraries-&gt;Add External JARs） java-client-5.0.4.jar selenium-java-3.8.1.zip selenium-server-standalone-3.8.1.jar 添加TestNG依赖（右键项目-&gt;Build Path-&gt;Configure Build Path-&gt;Libraries-&gt;Add Library-&gt;TestNG） 新建一个包和一个类 到此，eclipse下项目的配置已经完成了。 使用TestNG TestNG使用起来比JUnit还要方便，你创建的类不需要继承某个特定类，只需使用注解即可，想要系统学习TestNG的同学可以看文末的链接，我这里只使用@BeforeTest 、@Test 、@AfterTest和 @Test(dependsOnMethods = {methodName}) 这些注解。 @BeforeTest注释的方法将在所有测试方法运行之前运行，我们可以在该方法下进行Appium的DesiredCapabilities（这个可以先不管，后面会讲）的初始化。1234567891011121314@BeforeTestpublic void initAppium() throws MalformedURLException &#123; DesiredCapabilities capabilities = new DesiredCapabilities(); capabilities.setCapability(\"deviceName\", \"emulator-5554\"); capabilities.setCapability(\"automationName\", \"Appium\"); capabilities.setCapability(\"platformName\", \"Android\"); capabilities.setCapability(\"platformVersion\", \"6.0\"); //支持中文输入 capabilities.setCapability(\"unicodeKeyboard\" ,true); capabilities.setCapability(\"resetKeyboard\", true); capabilities.setCapability(\"appPackage\", \"com.allelink.wzyx\"); capabilities.setCapability(\"appActivity\", \"com.allelink.wzyx.activity.SplashActivity\"); driver = new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), capabilities);&#125; @Test将类或方法标记为测试的一部分，我们将在改方法下写测试用例。12345678910111213141516171819@Testpublic void testLoginSuccess() throws InterruptedException &#123; driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); List&lt;WebElement&gt; loginInputs = driver.findElementsByClassName(\"android.widget.EditText\"); //用户名输入框 WebElement userName = loginInputs.get(0); //密码输入框 WebElement password = loginInputs.get(1); WebElement loginBtn = driver.findElement(By.id(\"btn_login_login\")); userName.sendKeys(\"\"); password.sendKeys(\"\"); //点击登录按钮 loginBtn.click(); Thread.sleep(5000); List&lt;WebElement&gt; homes = driver.findElementsByClassName(\"android.widget.TextView\"); WebElement home = homes.get(0); assertTrue(home.getAttribute(\"name\").equals(\"首页\")); &#125; @AfterTest注释的方法将在属于所有测试方法运行之后运行，在这里我们可以用来关闭测试的应用。1234@AfterTestpublic void endTest() &#123; driver.quit();&#125; @Test(dependsOnMethods = {methodName})在TestNG中，我们使用dependOnMethods来实现依赖测试。 如果依赖方法失败，则将跳过所有后续测试方法，如果依赖方法成功则将执行下面的测试方法。 常见的场景：只有在登录成功后才能进入到应用的首页；只有订单提交成功后才能进行订单的支付。 使用AppiumDesiredCapabilities在使用Appium前，我们有必要了解 DesiredCapabilities ，DesiredCapabilities 在启动 session 的时候是必须提供的，是以 key value 字典的方式存放，客户端将这些键值对发给服务端，告诉服务端我们想要怎么测试。 它告诉 appium Server这样一些事情： automationName：使用哪种自动化引擎，默认是Appium platformName：测试的平台 Android、iOS platformVersion：指定平台的系统版本，Android 版本最好不要使用 6.0 以上的，貌似在7.0版本的设备上不兼容 deviceName：设备名，可以使用 adb devices 命令来查看 appPackage：测试应用的包名，如微信的包名为com.tencent.mm appActivity：测试应用的启动Activity，这里要注意的是如果测试的应用是系统自带的比如计算器，可以写成“.Calculaor”，如果不是的话建议写全，如com.tencent.mm.activity.SplashActivity unicodeKeyboard：如果要输入中文的话，可以给这个值为true resetKeyboard：和上面的成对使用 12345678910DesiredCapabilities capabilities = new DesiredCapabilities();capabilities.setCapability(\"deviceName\", \"emulator-5554\");capabilities.setCapability(\"automationName\", \"Appium\");capabilities.setCapability(\"platformName\", \"Android\");capabilities.setCapability(\"platformVersion\", \"6.0\");//支持中文输入capabilities.setCapability(\"unicodeKeyboard\" ,true);capabilities.setCapability(\"resetKeyboard\", true);capabilities.setCapability(\"appPackage\", \"com.allelink.wzyx\");capabilities.setCapability(\"appActivity\", \"com.allelink.wzyx.activity.SplashActivity\"); AndroidDriverAndroidDriver为我们提供了一系列操作Android应用的方法，我们要做的是在@BeforeTest下初始化它1driver = new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), capabilities); 上面的 127.0.0.1 是 Appium-server 的地址，4723 为其的端口号，要将 AndroidDriver 声明为全局变量，方便其他方法调用。 延时（显示/隐示）一旦我们编写好自动化测试脚本，执行之后，它将不会在适当的地方下来，比如启动页的几秒等待，网络数据的加载等等，这就需要我们在代码中进行延时，其中延时又分为显示和隐示 显示延时：使用 Thread.sleep() 来延时 隐示延时：使用 driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); 界面元素定位uiautomatorviewerappium 通过 uiautomatorviewer.bat 工具来查看控件的属性。该工具位于 Android SDK 的 /tools/bin/ 目录下，为了以后方便使用我们可以将其所在的目录添加到系统环境变量中去。 在命令行中输入uiautomatorviewer启动uiautomatorviewer 元素定位AndroidDriver 为我们提供了比较多的定位方式，这里推荐使用 id 定位 id 定位这里以微信为例，如下图所示，在resource-id这一栏显示就是这个TextView的id。那我们可以通过driver.findElement(By.id(&quot;title&quot;));来获取这个元素，记得使用的是android:id/后面的值。 这样我们就获取到了这个元素，其类型是 WebElement 然后可以调用它的click方法来实现点击。12WebElement near = driver.findElement(By.id(\"ll_bottom_bar_near_tab_layout\"));near.click(); 所以我们在进行 Android 应用开发的过程中应该要多为元素写上 id 。 测试实战下面我将使用TestNG+Appium为大家带来一个自动化测试的例子，测试的内容是应用的登录功能 声明一个AndroidDriver的全局变量 1AndroidDriver driver; 在@BeforeTest注解下初始化DesiredCapabilities，我这里使用的Android 6.0 的模拟器 1234567891011121314@BeforeTestpublic void initAppium() throws MalformedURLException &#123; DesiredCapabilities capabilities = new DesiredCapabilities(); capabilities.setCapability(\"deviceName\", \"emulator-5554\"); capabilities.setCapability(\"automationName\", \"Appium\"); capabilities.setCapability(\"platformName\", \"Android\"); capabilities.setCapability(\"platformVersion\", \"6.0\"); //支持中文输入 capabilities.setCapability(\"unicodeKeyboard\" ,true); capabilities.setCapability(\"resetKeyboard\", true); capabilities.setCapability(\"appPackage\", \"com.allelink.wzyx\"); capabilities.setCapability(\"appActivity\", \"com.allelink.wzyx.activity.SplashActivity\"); driver = new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), capabilities);&#125; 在@Test注解下测试登录功能，这里需要说明的是我们可以使用sendKeys来模拟键盘的输入，最后可以通过判断首页是否显示来判断登录是否成功。 123456789101112131415161718@Testpublic void testLoginSuccess() throws InterruptedException &#123; driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); List&lt;WebElement&gt; loginInputs = driver.findElementsByClassName(\"android.widget.EditText\"); //用户名输入框 WebElement userName = loginInputs.get(0); //密码输入框 WebElement password = loginInputs.get(1); WebElement loginBtn = driver.findElement(By.id(\"btn_login_login\")); userName.sendKeys(\"15700178425\"); password.sendKeys(\"test123\"); //点击登录按钮 loginBtn.click(); Thread.sleep(5000); List&lt;WebElement&gt; homes = driver.findElementsByClassName(\"android.widget.TextView\"); WebElement home = homes.get(0); assertTrue(home.getAttribute(\"name\").equals(\"首页\"));&#125; 在@AfterTest注解下关闭应用 1234@AfterTestpublic void endTest() &#123; driver.quit();&#125; 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940public class AppTest &#123; AndroidDriver driver; @BeforeTest public void initAppium() throws MalformedURLException &#123; DesiredCapabilities capabilities = new DesiredCapabilities(); capabilities.setCapability(\"deviceName\", \"emulator-5554\"); capabilities.setCapability(\"automationName\", \"Appium\"); capabilities.setCapability(\"platformName\", \"Android\"); capabilities.setCapability(\"platformVersion\", \"6.0\"); //支持中文输入 capabilities.setCapability(\"unicodeKeyboard\" ,true); capabilities.setCapability(\"resetKeyboard\", true); capabilities.setCapability(\"appPackage\", \"com.allelink.wzyx\"); capabilities.setCapability(\"appActivity\", \"com.allelink.wzyx.activity.SplashActivity\"); driver = new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), capabilities); &#125; @Test public void testLoginSuccess() throws InterruptedException &#123; driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); List&lt;WebElement&gt; loginInputs = driver.findElementsByClassName(\"android.widget.EditText\"); //用户名输入框 WebElement userName = loginInputs.get(0); //密码输入框 WebElement password = loginInputs.get(1); WebElement loginBtn = driver.findElement(By.id(\"btn_login_login\")); userName.sendKeys(\"15700178425\"); password.sendKeys(\"ych123\"); //点击登录按钮 loginBtn.click(); Thread.sleep(5000); List&lt;WebElement&gt; homes = driver.findElementsByClassName(\"android.widget.TextView\"); WebElement home = homes.get(0); assertTrue(home.getAttribute(\"name\").equals(\"首页\")); &#125; @AfterTest public void endTest() &#123; driver.quit(); &#125;&#125; 想要更系统的学习自动化测试可看下面的链接 移动 App 自动化测试框架 Appium 教程TestNG 教程","categories":[{"name":"Android自动化测试","slug":"Android自动化测试","permalink":"http://yoursite.com/categories/Android自动化测试/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"http://yoursite.com/tags/TestNG/"},{"name":"Appium","slug":"Appium","permalink":"http://yoursite.com/tags/Appium/"}]},{"title":"使用TestNG和Appium进行Android自动化测试(一)","slug":"android-automated-test-by-testng-appium-one","date":"2017-12-17T11:00:50.000Z","updated":"2017-12-17T12:33:22.693Z","comments":true,"path":"2017/12/17/android-automated-test-by-testng-appium-one/","link":"","permalink":"http://yoursite.com/2017/12/17/android-automated-test-by-testng-appium-one/","excerpt":"前言 因项目需要使用到Android自动化测试，自己就抽空学习了下，了解到目前主流的是采用TestNG和Appium来进行Android自动化测试，写下这篇博客来记录这几天的学习历程。","text":"前言 因项目需要使用到Android自动化测试，自己就抽空学习了下，了解到目前主流的是采用TestNG和Appium来进行Android自动化测试，写下这篇博客来记录这几天的学习历程。 Appium 是什么？appium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web应用和混合应用，我这里写的是Android平台下的自动化测试，对其他平台自动化测试感兴趣的话可以自己找资料学习。 安装Appium我们要使用Appium必须要在本地电脑里安装Appium-Server，但是官方早在2015-12-08之后就再也没更新过这个Appium-Server了，要说用的话还是可以用的，不过这里推荐大家使用appium-desktop，这也是官方开发的appium桌面端，点我下载 ，安装步骤的话一直点下一步就行了。 运行Appium在桌面上找到Appium的图标点击运行，可以看到如下的界面 host: appium-server的主机地址，建议你改为127.0.0.1 port: appium-server要监听的端口，默认为4723，建议不需要修改 点击Start Server后，可以看到下面的界面，说明已经启动成功了 使用Appium使用Appium需要以下几个jar/zip 下载链接：https://pan.baidu.com/s/1qYiKl1E 密码：xug0 java-client-5.0.4.jar selenium-java-3.8.1.zip selenium-server-standalone-3.8.1.jar 不要问我为什么是这三个东东下就是了 TestNG是什么？TestNG是一个开源自动化测试框架，TestNG表示下一代(Next Generation的首字母)，其灵感来自JUnit和NUnit，但引入了一些新的功能，使其功能更强大，使用更方便。 安装TestNG这里推荐使用eclipse的在线安装，安装步骤如下 选择菜单：Help-&gt;Eclipse Marketplace，然后在search框中输入testng，点击右边的Go按钮，找到TestNG for Eclipse 点击Install，等待安装 直到Finished之后，重启Eclipse完成安装 到此Android自动化测试的工具你都应该下好了，那么使用TestNG和Appium进行Android自动化测试(二)将会介绍如何使用它们。","categories":[{"name":"Android自动化测试","slug":"Android自动化测试","permalink":"http://yoursite.com/categories/Android自动化测试/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"http://yoursite.com/tags/TestNG/"},{"name":"Appium","slug":"Appium","permalink":"http://yoursite.com/tags/Appium/"}]},{"title":"使用Hexo和GitHub来搭建个人博客","slug":"use-hexo-github-to-make-blog","date":"2017-12-14T12:08:40.000Z","updated":"2017-12-17T11:11:49.786Z","comments":true,"path":"2017/12/14/use-hexo-github-to-make-blog/","link":"","permalink":"http://yoursite.com/2017/12/14/use-hexo-github-to-make-blog/","excerpt":"前言 最近看到网上有很多使用Hexo来搭建的个人博客，风格也有很多，属next主题最为简洁和成熟，使用的人数也最多，自己也忍不住也花了一天时间搭了一个，期间也踩了一些坑，想写下这篇博客来记录一下搭建过程，供其他人参考。","text":"前言 最近看到网上有很多使用Hexo来搭建的个人博客，风格也有很多，属next主题最为简洁和成熟，使用的人数也最多，自己也忍不住也花了一天时间搭了一个，期间也踩了一些坑，想写下这篇博客来记录一下搭建过程，供其他人参考。 需要使用的工具 git Node.js Hexo GitHub 一个域名（可选） 安装安装Git （可参考 官方安装教程 ） Windows：下载安装 git 下载 Mac: 下载 安装程序 安装 安装Node.js Node.js 下载地址 安装步骤参考 其实就是一直点击下一步 在命令行下输入 node -v，如果显示了当前node.js的版本号说明node.js安装成功，如下图所示 安装Hexo (可参考 官方教程)安装好了Node.js ，再安装Hexo就很简单了哈，在任意位置右键点击Git Bash Here打开命令行，再输入以下命令 1npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在E盘目录下创建了一个文件夹 blog 。E:\\blog ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。 1hexo init 命令执行完后，会在该目录下新建如下文件 12345678.├── _config.yml ├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 其中_config.yml是站点配置文件，可以用来修改站点名，站点拥有者，修改主题等相关信息；_posts文件下存放的是你写的博客（markdown格式的文件） 预览默认的主题执行如下的命令（记得是使用Git Bash 打开的命令行工具哈）123hexo clean //清除缓存hexo generate //生成静态文件hexo server //启动本地服务器，默认端口是4000 第一个坑：如果你的电脑里装有福昕阅读器，那么恭喜你，执行上述命令后，你打不开http://localhost:4000/，福昕阅读器的程序员哥哥把4000给占了，我们需要给hexo开过一个端口，执行如下命令可以将端口切换到5000 1hexo s -p 5000 hexo 默认的主题如下图所示 到目前为止我们所做的工作全在本地，那么接下来我们需要使用到GitHub啦部署到GitHub上 一个GitHub账号是必须 创建一个仓库 输入的仓库名的格式为：你的github用户名.github,io（格式千万不能错啊） 将Hexo与github 联系起来 配置git个人信息（如果已经配置过了，可以跳过） 12git config --global user.name \"yangchendev\"git config --global user.email \"yangchendev@qq.com\" 生成秘钥 这里是第二个坑，你的电脑可能没有.ssh文件夹，你需要手动创建一个 1mkdir ~/.ssh 再使用 12cd ~/.sshssh-keygen -t rsa -C \"yangchendev@qq.com\" //在这个命令后一直回车就行 生成的id_rsa.pub在如下的目录 用记事本打开id_rsa.pub，把里面的内容全部复制 接下来是在github上添加SSH Key 最后在你的博客根目录下打开_config.yml在其中添加如下信息 repo 后填你刚刚新建的那个仓库地址 哈哈，第三个坑来啦，我们在修改_config.yml时，需要在“：”后添加一个空格再写值，不然会出错 安装hexo-deployer-git自动部署发布工具使用如下命令安装（记得在博客的根目录下打开git bash） 1npm install hexo-deployer-git --save 最后使用三部曲将博客发布到GitHub上 123hexo cleanhexo generatehexo deploy 第一次可能要求你添加GitHub的账号和密码，正常执行的效果如下图所示 上传成功后你可以在仓库中看到你上传的代码 你可以使用 你的GitHub名.github.io 来访问你的博客了，是不是很6啊 我知道你可能不会满足于此我们完全可以使用我们自己的域名来访问自己的博客，这样是不是更高大上了 这里我推荐在阿里云的万网上购买域名（我购买的是.top 比较便宜哈哈），域名购买成功后，你需要为你的域名添加解析 这里要添加三个解析： 第一个的记录值是github为你分配的地址，即你的github名.github.io 第二个和第三个是github服务器的地址，不填的话会无法访问github的啦 当然还有一个操作是为你的仓库设置自定义的域名，这样就可以通过这个域名来访问 你的github名.github.io Hexo 主题Hexo 有很多主题可供我们使用，这里我推荐使用 next主题官网有详细的使用说明，大家看看就会了，我也会推荐一篇教程。 瞅瞅我的博客 参考文档： Git安装及SSH Key管理之Windows篇 Hexo-NexT搭建个人博客 hexo的next主题个性化教程:打造炫酷网站","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]}]}