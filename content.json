{"meta":{"title":"Yang Chen's Blog","subtitle":null,"description":null,"author":"杨晨","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-17T10:58:45.663Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我Hi，我是杨晨，一个菜鸟级Android工程师，目前就读于浙江大学软件学院，是一名研一的学生，对Android开发情有独钟，立志成为一名高级Android开发工程师。 关于本博客 2017.12.14：使用Hexo+GitHub创建本博客，使用的是NexT主题，评论系统采用来必力。"},{"title":"归档","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-14T11:48:19.198Z","comments":false,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-14T09:59:01.154Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-14T10:01:18.349Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Fragment基础知识","slug":"android-fragment","date":"2018-01-13T04:02:00.000Z","updated":"2018-01-13T04:05:25.986Z","comments":true,"path":"2018/01/13/android-fragment/","link":"","permalink":"http://yoursite.com/2018/01/13/android-fragment/","excerpt":"为什么说Fragment是Android中的第五大组件Fragment是在Android 3.0之后提出来的，目的是为了解决平板上的显示效果，如下图所示。 从目前的Android应用的架构来说，主流使用的是多Activity+多Fragment这种模式，即一个Activity管理多个Fragment，比如说一个Activity管理登录、注册和忘记密码这几个Fragment。由此可以看出Fragment的使用频率已经不低于Activity了，并且Fragment具有更低的内存消耗，页面间的切换也更加的流畅。还有一个原因就是Fragment拥有自己的生命周期，不过它必须依附于Activity。","text":"为什么说Fragment是Android中的第五大组件Fragment是在Android 3.0之后提出来的，目的是为了解决平板上的显示效果，如下图所示。 从目前的Android应用的架构来说，主流使用的是多Activity+多Fragment这种模式，即一个Activity管理多个Fragment，比如说一个Activity管理登录、注册和忘记密码这几个Fragment。由此可以看出Fragment的使用频率已经不低于Activity了，并且Fragment具有更低的内存消耗，页面间的切换也更加的流畅。还有一个原因就是Fragment拥有自己的生命周期，不过它必须依附于Activity。 Fragment的两种创建方式 直接把Fragment写在布局中，把它当做一个控件来使用，这里需要为fragment标签绑定Fragment，即填写name属性即可 12345&lt;fragment android:id=\"@+id/id_fragment_title\" android:name=\"com.yangc.fragments.TitleFragment\" android:layout_width=\"fill_parent\" android:layout_height=\"45dp\" /&gt; 使用FragmentManager来动态的增删 1234567891011121314151617181920212223242526动态的增删需要为Fragment指定一个布局容器来填充，如FrameLayout、RelativeLayout等 FragmentManager fm = getFragmentManager(); // 开启Fragment事务 FragmentTransaction transaction = fm.beginTransaction(); switch (v.getId()) &#123; case R.id.tab_bottom_weixin: if (mWeixin == null) &#123; mWeixin = new ContentFragment(); &#125; // 使用当前Fragment的布局替代id_content的控件 transaction.replace(R.id.id_content, mWeixin); break; case R.id.tab_bottom_friend: if (mFriend == null) &#123; mFriend = new FriendFragment(); &#125; transaction.replace(R.id.id_content, mFriend); break; &#125; // 事务提交 transaction.commit(); &#125; 这里需要注意的是FragmentTransaction transaction = fm.beginTransaction();和transaction.commit();需要成对的使用。 FragmentPageAdapter和FragmentStatePageAdapter的区别 通常Fragment会和ViewPager一起配合着使用，来实现左右滑动切换页面的效果。 FragmentPageAdapter使用在页面比较少的情况下，而FragmentStatePageAdapter使用在页面比较多的情况下，从源码中可以发现，FragmentPageAdapter在销毁每个item时是使用detach()方法，这个方法仅仅只是在UI层面上将Fragment进行脱离并没有销毁这个item，如下图所示。 而FragmentStatePageAdapter在销毁每个item时使用的是remove()方法，这个方法会销毁这个item，如下图所示，所以FragmentStatePageAdapter对内存更友好。 Fragment的生命周期Fragment的生命周期是依赖于Activity的，它不能单独存在，下图是其生命周期。 下面来对Fragment的生命周期和Activity的生命周期一起进行分析，如下图所示。 创建Fragment调用onAttach()方法，将Fragment与Activity进行关联，再调用onCreate()方法，调用onCreateView()方法，这个方法就是返回我们自己布局的，注意要返回根布局，View创建好后会调用onViewCreated()方法，再是Activity的onCreate()方法，启动Activity后会调用onActivityCreated方法，在是Activity的onStart方法，Fragment的onStart方法，Activity的onResume方法，Fragment的onResume()，到此Fragment已经可见并可以交互了。 Fragment的通信有以下三种方式： 在Fragment中调用Activity中的方法使用getActivity()，获取其宿主Activity 在Activity中调用Fragment中的方法，需要在Fragment定义接口，在Activity中实现这个接口，即接口回调 在Fragment中调用另一个Fragment中的方法，使用getActivity方法获取到宿主Activity，在调用Activity中的findFragmentById方法获取另一个Fragment。 Fragment的切换 replace：移除掉（实例会被回收掉）栈中的其他所有Fragment，并将当前Fragment添加到栈中，这种方式会使栈中仅有一个Fragment，并且每次都会新建Fragment实例。 add&amp;remove：add会在栈中创建一个Fragment实例，而remove会销毁一个Fragment。 hide&amp;show：把前面的Fragment隐藏掉了，把新的Fragment添加到栈中，并不会销毁之前的Fragment，不过这种方式会销毁比较多的内存，是开发中最常用的方式。 attach&amp;detach：attach会重绘制View，detach不会销毁Fragment实例，而是销毁其View，这种方式比较鸡肋，开发中不常用。","categories":[{"name":"Android基础知识","slug":"Android基础知识","permalink":"http://yoursite.com/categories/Android基础知识/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://yoursite.com/tags/Fragment/"}]},{"title":"Activity基础知识","slug":"android-activity","date":"2018-01-13T01:48:00.000Z","updated":"2018-01-13T01:53:29.129Z","comments":true,"path":"2018/01/13/android-activity/","link":"","permalink":"http://yoursite.com/2018/01/13/android-activity/","excerpt":"Activity是什么？通俗点说Activity就是能与用户进行交互的界面，如点击、长按、上拉下滑等等。 Activity的4中状态 running：运行状态，位于前台可与用户进行交互 paused：暂停状态，可见但不可与用户进行交互 stopped：停止状态，位于后台不可见 killed：被杀死状态，被回收","text":"Activity是什么？通俗点说Activity就是能与用户进行交互的界面，如点击、长按、上拉下滑等等。 Activity的4中状态 running：运行状态，位于前台可与用户进行交互 paused：暂停状态，可见但不可与用户进行交互 stopped：停止状态，位于后台不可见 killed：被杀死状态，被回收 Activity的生命周期下面是官网的一张图，有个大致的映像即可。 主要说下面的几种情况： 1. Activity启动 &gt; onCreate()-&gt;onStart()-&gt;onResume() 2. 用户按下HOME键 &gt; onPause()-&gt;onStop() 3. 重新打开之前的Activity &gt; onRestart()-&gt;onStart()-&gt;onResume() 4. 正常退出当前Activity &gt; onPause()-&gt;onStop()-&gt;onDestroy() Android进程的优先级我们都知道在内存不足的时候系统会回收优先级低的进程。 前台-&gt;可见-&gt;服务-&gt;后台-&gt;空 前台：用户看得见并且可以交互 可见：用户看到见但不可交互，举个简单的例子就是有个透明的Activity覆盖住了之前的Activity，那么之前的Activity就从前台转到了后台 服务：就是在后台一直运行的services 后台：与服务不同的是后台是由前台转换过来的，按下home键后之前的Activity就处于后台了 空：优先级最低，不属于以上的类型，Android系统可随时杀掉该进程Android的任务栈在Android中，Activity是存在于任务栈中，任务栈是一种栈结构，存放Activity的集合，如下图所示，是一种先进后出的结构。 Activity在一定情况下可以单独占用一个任务栈，这里涉及到Activity的启动模式（后面再说）。 Activity的启动模式Activity的启动模式一共分为4种 standard：默认的是这个模式，每次创建一个Activity时都会新建一个实例，它不管任务栈中是否存在该实例，这样模式会消耗比较大的内存。 singleTop：又叫做栈顶复用模式，每次创建一个新的Activity时都会在任务栈顶查看是否有该实例，如果有则复用，没有才创建。 singleTask：该模式会一直复用任务栈中Activity实例，需要注意的是它会清除它之上的Activity从而是自己到达栈顶，用的比较多的地方就是一个应用的主页。 singleInstance：该模式下创建Activity时会为这个Activity单独创建一个任务栈，用的比较多的一个场景是消息推送，用户点击通知栏上的消息进入到一个Activity中，当用户按下返回键时会之间退出这个应用，而不是进入到这个应用中，因为这个任务栈中只有这个Activity。","categories":[{"name":"Android基础知识","slug":"Android基础知识","permalink":"http://yoursite.com/categories/Android基础知识/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"http://yoursite.com/tags/Activity/"}]},{"title":"使用TestNG和Appium进行Android自动化测试(二)","slug":"android-automated-test-by-testng-appium-two","date":"2017-12-19T09:56:20.000Z","updated":"2017-12-19T12:23:11.870Z","comments":true,"path":"2017/12/19/android-automated-test-by-testng-appium-two/","link":"","permalink":"http://yoursite.com/2017/12/19/android-automated-test-by-testng-appium-two/","excerpt":"前言 看过了上一篇使用TestNG和Appium进行Android自动化测试(一)，相信你已经把所需要的资源都准备好了，接下来就来看看如何使用TestNG和Appium进行Android的自动化测试。","text":"前言 看过了上一篇使用TestNG和Appium进行Android自动化测试(一)，相信你已经把所需要的资源都准备好了，接下来就来看看如何使用TestNG和Appium进行Android的自动化测试。 eclipse项目的配置导入jar/zip 创建一个Java Project(File-&gt;New-&gt;Java Project) 导入（右键项目-&gt;Build Path-&gt;Configure Build Path-&gt;Libraries-&gt;Add External JARs） java-client-5.0.4.jar selenium-java-3.8.1.zip selenium-server-standalone-3.8.1.jar 添加TestNG依赖（右键项目-&gt;Build Path-&gt;Configure Build Path-&gt;Libraries-&gt;Add Library-&gt;TestNG） 新建一个包和一个类 到此，eclipse下项目的配置已经完成了。 使用TestNG TestNG使用起来比JUnit还要方便，你创建的类不需要继承某个特定类，只需使用注解即可，想要系统学习TestNG的同学可以看文末的链接，我这里只使用@BeforeTest 、@Test 、@AfterTest和 @Test(dependsOnMethods = {methodName}) 这些注解。 @BeforeTest注释的方法将在所有测试方法运行之前运行，我们可以在该方法下进行Appium的DesiredCapabilities（这个可以先不管，后面会讲）的初始化。1234567891011121314@BeforeTestpublic void initAppium() throws MalformedURLException &#123; DesiredCapabilities capabilities = new DesiredCapabilities(); capabilities.setCapability(\"deviceName\", \"emulator-5554\"); capabilities.setCapability(\"automationName\", \"Appium\"); capabilities.setCapability(\"platformName\", \"Android\"); capabilities.setCapability(\"platformVersion\", \"6.0\"); //支持中文输入 capabilities.setCapability(\"unicodeKeyboard\" ,true); capabilities.setCapability(\"resetKeyboard\", true); capabilities.setCapability(\"appPackage\", \"com.allelink.wzyx\"); capabilities.setCapability(\"appActivity\", \"com.allelink.wzyx.activity.SplashActivity\"); driver = new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), capabilities);&#125; @Test将类或方法标记为测试的一部分，我们将在改方法下写测试用例。12345678910111213141516171819@Testpublic void testLoginSuccess() throws InterruptedException &#123; driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); List&lt;WebElement&gt; loginInputs = driver.findElementsByClassName(\"android.widget.EditText\"); //用户名输入框 WebElement userName = loginInputs.get(0); //密码输入框 WebElement password = loginInputs.get(1); WebElement loginBtn = driver.findElement(By.id(\"btn_login_login\")); userName.sendKeys(\"\"); password.sendKeys(\"\"); //点击登录按钮 loginBtn.click(); Thread.sleep(5000); List&lt;WebElement&gt; homes = driver.findElementsByClassName(\"android.widget.TextView\"); WebElement home = homes.get(0); assertTrue(home.getAttribute(\"name\").equals(\"首页\")); &#125; @AfterTest注释的方法将在属于所有测试方法运行之后运行，在这里我们可以用来关闭测试的应用。1234@AfterTestpublic void endTest() &#123; driver.quit();&#125; @Test(dependsOnMethods = {methodName})在TestNG中，我们使用dependOnMethods来实现依赖测试。 如果依赖方法失败，则将跳过所有后续测试方法，如果依赖方法成功则将执行下面的测试方法。 常见的场景：只有在登录成功后才能进入到应用的首页；只有订单提交成功后才能进行订单的支付。 使用AppiumDesiredCapabilities在使用Appium前，我们有必要了解 DesiredCapabilities ，DesiredCapabilities 在启动 session 的时候是必须提供的，是以 key value 字典的方式存放，客户端将这些键值对发给服务端，告诉服务端我们想要怎么测试。 它告诉 appium Server这样一些事情： automationName：使用哪种自动化引擎，默认是Appium platformName：测试的平台 Android、iOS platformVersion：指定平台的系统版本，Android 版本最好不要使用 6.0 以上的，貌似在7.0版本的设备上不兼容 deviceName：设备名，可以使用 adb devices 命令来查看 appPackage：测试应用的包名，如微信的包名为com.tencent.mm appActivity：测试应用的启动Activity，这里要注意的是如果测试的应用是系统自带的比如计算器，可以写成“.Calculaor”，如果不是的话建议写全，如com.tencent.mm.activity.SplashActivity unicodeKeyboard：如果要输入中文的话，可以给这个值为true resetKeyboard：和上面的成对使用 12345678910DesiredCapabilities capabilities = new DesiredCapabilities();capabilities.setCapability(\"deviceName\", \"emulator-5554\");capabilities.setCapability(\"automationName\", \"Appium\");capabilities.setCapability(\"platformName\", \"Android\");capabilities.setCapability(\"platformVersion\", \"6.0\");//支持中文输入capabilities.setCapability(\"unicodeKeyboard\" ,true);capabilities.setCapability(\"resetKeyboard\", true);capabilities.setCapability(\"appPackage\", \"com.allelink.wzyx\");capabilities.setCapability(\"appActivity\", \"com.allelink.wzyx.activity.SplashActivity\"); AndroidDriverAndroidDriver为我们提供了一系列操作Android应用的方法，我们要做的是在@BeforeTest下初始化它1driver = new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), capabilities); 上面的 127.0.0.1 是 Appium-server 的地址，4723 为其的端口号，要将 AndroidDriver 声明为全局变量，方便其他方法调用。 延时（显示/隐示）一旦我们编写好自动化测试脚本，执行之后，它将不会在适当的地方下来，比如启动页的几秒等待，网络数据的加载等等，这就需要我们在代码中进行延时，其中延时又分为显示和隐示 显示延时：使用 Thread.sleep() 来延时 隐示延时：使用 driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); 界面元素定位uiautomatorviewerappium 通过 uiautomatorviewer.bat 工具来查看控件的属性。该工具位于 Android SDK 的 /tools/bin/ 目录下，为了以后方便使用我们可以将其所在的目录添加到系统环境变量中去。 在命令行中输入uiautomatorviewer启动uiautomatorviewer 元素定位AndroidDriver 为我们提供了比较多的定位方式，这里推荐使用 id 定位 id 定位这里以微信为例，如下图所示，在resource-id这一栏显示就是这个TextView的id。那我们可以通过driver.findElement(By.id(&quot;title&quot;));来获取这个元素，记得使用的是android:id/后面的值。 这样我们就获取到了这个元素，其类型是 WebElement 然后可以调用它的click方法来实现点击。12WebElement near = driver.findElement(By.id(\"ll_bottom_bar_near_tab_layout\"));near.click(); 所以我们在进行 Android 应用开发的过程中应该要多为元素写上 id 。 测试实战下面我将使用TestNG+Appium为大家带来一个自动化测试的例子，测试的内容是应用的登录功能 声明一个AndroidDriver的全局变量 1AndroidDriver driver; 在@BeforeTest注解下初始化DesiredCapabilities，我这里使用的Android 6.0 的模拟器 1234567891011121314@BeforeTestpublic void initAppium() throws MalformedURLException &#123; DesiredCapabilities capabilities = new DesiredCapabilities(); capabilities.setCapability(\"deviceName\", \"emulator-5554\"); capabilities.setCapability(\"automationName\", \"Appium\"); capabilities.setCapability(\"platformName\", \"Android\"); capabilities.setCapability(\"platformVersion\", \"6.0\"); //支持中文输入 capabilities.setCapability(\"unicodeKeyboard\" ,true); capabilities.setCapability(\"resetKeyboard\", true); capabilities.setCapability(\"appPackage\", \"com.allelink.wzyx\"); capabilities.setCapability(\"appActivity\", \"com.allelink.wzyx.activity.SplashActivity\"); driver = new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), capabilities);&#125; 在@Test注解下测试登录功能，这里需要说明的是我们可以使用sendKeys来模拟键盘的输入，最后可以通过判断首页是否显示来判断登录是否成功。 123456789101112131415161718@Testpublic void testLoginSuccess() throws InterruptedException &#123; driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); List&lt;WebElement&gt; loginInputs = driver.findElementsByClassName(\"android.widget.EditText\"); //用户名输入框 WebElement userName = loginInputs.get(0); //密码输入框 WebElement password = loginInputs.get(1); WebElement loginBtn = driver.findElement(By.id(\"btn_login_login\")); userName.sendKeys(\"15700178425\"); password.sendKeys(\"test123\"); //点击登录按钮 loginBtn.click(); Thread.sleep(5000); List&lt;WebElement&gt; homes = driver.findElementsByClassName(\"android.widget.TextView\"); WebElement home = homes.get(0); assertTrue(home.getAttribute(\"name\").equals(\"首页\"));&#125; 在@AfterTest注解下关闭应用 1234@AfterTestpublic void endTest() &#123; driver.quit();&#125; 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940public class AppTest &#123; AndroidDriver driver; @BeforeTest public void initAppium() throws MalformedURLException &#123; DesiredCapabilities capabilities = new DesiredCapabilities(); capabilities.setCapability(\"deviceName\", \"emulator-5554\"); capabilities.setCapability(\"automationName\", \"Appium\"); capabilities.setCapability(\"platformName\", \"Android\"); capabilities.setCapability(\"platformVersion\", \"6.0\"); //支持中文输入 capabilities.setCapability(\"unicodeKeyboard\" ,true); capabilities.setCapability(\"resetKeyboard\", true); capabilities.setCapability(\"appPackage\", \"com.allelink.wzyx\"); capabilities.setCapability(\"appActivity\", \"com.allelink.wzyx.activity.SplashActivity\"); driver = new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), capabilities); &#125; @Test public void testLoginSuccess() throws InterruptedException &#123; driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS); List&lt;WebElement&gt; loginInputs = driver.findElementsByClassName(\"android.widget.EditText\"); //用户名输入框 WebElement userName = loginInputs.get(0); //密码输入框 WebElement password = loginInputs.get(1); WebElement loginBtn = driver.findElement(By.id(\"btn_login_login\")); userName.sendKeys(\"15700178425\"); password.sendKeys(\"ych123\"); //点击登录按钮 loginBtn.click(); Thread.sleep(5000); List&lt;WebElement&gt; homes = driver.findElementsByClassName(\"android.widget.TextView\"); WebElement home = homes.get(0); assertTrue(home.getAttribute(\"name\").equals(\"首页\")); &#125; @AfterTest public void endTest() &#123; driver.quit(); &#125;&#125; 想要更系统的学习自动化测试可看下面的链接 移动 App 自动化测试框架 Appium 教程TestNG 教程","categories":[{"name":"Android自动化测试","slug":"Android自动化测试","permalink":"http://yoursite.com/categories/Android自动化测试/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"http://yoursite.com/tags/TestNG/"},{"name":"Appium","slug":"Appium","permalink":"http://yoursite.com/tags/Appium/"}]},{"title":"使用TestNG和Appium进行Android自动化测试(一)","slug":"android-automated-test-by-testng-appium-one","date":"2017-12-17T11:00:50.000Z","updated":"2017-12-17T12:33:22.693Z","comments":true,"path":"2017/12/17/android-automated-test-by-testng-appium-one/","link":"","permalink":"http://yoursite.com/2017/12/17/android-automated-test-by-testng-appium-one/","excerpt":"前言 因项目需要使用到Android自动化测试，自己就抽空学习了下，了解到目前主流的是采用TestNG和Appium来进行Android自动化测试，写下这篇博客来记录这几天的学习历程。","text":"前言 因项目需要使用到Android自动化测试，自己就抽空学习了下，了解到目前主流的是采用TestNG和Appium来进行Android自动化测试，写下这篇博客来记录这几天的学习历程。 Appium 是什么？appium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web应用和混合应用，我这里写的是Android平台下的自动化测试，对其他平台自动化测试感兴趣的话可以自己找资料学习。 安装Appium我们要使用Appium必须要在本地电脑里安装Appium-Server，但是官方早在2015-12-08之后就再也没更新过这个Appium-Server了，要说用的话还是可以用的，不过这里推荐大家使用appium-desktop，这也是官方开发的appium桌面端，点我下载 ，安装步骤的话一直点下一步就行了。 运行Appium在桌面上找到Appium的图标点击运行，可以看到如下的界面 host: appium-server的主机地址，建议你改为127.0.0.1 port: appium-server要监听的端口，默认为4723，建议不需要修改 点击Start Server后，可以看到下面的界面，说明已经启动成功了 使用Appium使用Appium需要以下几个jar/zip 下载链接：https://pan.baidu.com/s/1qYiKl1E 密码：xug0 java-client-5.0.4.jar selenium-java-3.8.1.zip selenium-server-standalone-3.8.1.jar 不要问我为什么是这三个东东下就是了 TestNG是什么？TestNG是一个开源自动化测试框架，TestNG表示下一代(Next Generation的首字母)，其灵感来自JUnit和NUnit，但引入了一些新的功能，使其功能更强大，使用更方便。 安装TestNG这里推荐使用eclipse的在线安装，安装步骤如下 选择菜单：Help-&gt;Eclipse Marketplace，然后在search框中输入testng，点击右边的Go按钮，找到TestNG for Eclipse 点击Install，等待安装 直到Finished之后，重启Eclipse完成安装 到此Android自动化测试的工具你都应该下好了，那么使用TestNG和Appium进行Android自动化测试(二)将会介绍如何使用它们。","categories":[{"name":"Android自动化测试","slug":"Android自动化测试","permalink":"http://yoursite.com/categories/Android自动化测试/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"http://yoursite.com/tags/TestNG/"},{"name":"Appium","slug":"Appium","permalink":"http://yoursite.com/tags/Appium/"}]},{"title":"使用Hexo和GitHub来搭建个人博客","slug":"use-hexo-github-to-make-blog","date":"2017-12-14T12:08:40.000Z","updated":"2017-12-17T11:11:49.786Z","comments":true,"path":"2017/12/14/use-hexo-github-to-make-blog/","link":"","permalink":"http://yoursite.com/2017/12/14/use-hexo-github-to-make-blog/","excerpt":"前言 最近看到网上有很多使用Hexo来搭建的个人博客，风格也有很多，属next主题最为简洁和成熟，使用的人数也最多，自己也忍不住也花了一天时间搭了一个，期间也踩了一些坑，想写下这篇博客来记录一下搭建过程，供其他人参考。","text":"前言 最近看到网上有很多使用Hexo来搭建的个人博客，风格也有很多，属next主题最为简洁和成熟，使用的人数也最多，自己也忍不住也花了一天时间搭了一个，期间也踩了一些坑，想写下这篇博客来记录一下搭建过程，供其他人参考。 需要使用的工具 git Node.js Hexo GitHub 一个域名（可选） 安装安装Git （可参考 官方安装教程 ） Windows：下载安装 git 下载 Mac: 下载 安装程序 安装 安装Node.js Node.js 下载地址 安装步骤参考 其实就是一直点击下一步 在命令行下输入 node -v，如果显示了当前node.js的版本号说明node.js安装成功，如下图所示 安装Hexo (可参考 官方教程)安装好了Node.js ，再安装Hexo就很简单了哈，在任意位置右键点击Git Bash Here打开命令行，再输入以下命令 1npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在E盘目录下创建了一个文件夹 blog 。E:\\blog ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。 1hexo init 命令执行完后，会在该目录下新建如下文件 12345678.├── _config.yml ├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 其中_config.yml是站点配置文件，可以用来修改站点名，站点拥有者，修改主题等相关信息；_posts文件下存放的是你写的博客（markdown格式的文件） 预览默认的主题执行如下的命令（记得是使用Git Bash 打开的命令行工具哈）123hexo clean //清除缓存hexo generate //生成静态文件hexo server //启动本地服务器，默认端口是4000 第一个坑：如果你的电脑里装有福昕阅读器，那么恭喜你，执行上述命令后，你打不开http://localhost:4000/，福昕阅读器的程序员哥哥把4000给占了，我们需要给hexo开过一个端口，执行如下命令可以将端口切换到5000 1hexo s -p 5000 hexo 默认的主题如下图所示 到目前为止我们所做的工作全在本地，那么接下来我们需要使用到GitHub啦部署到GitHub上 一个GitHub账号是必须 创建一个仓库 输入的仓库名的格式为：你的github用户名.github,io（格式千万不能错啊） 将Hexo与github 联系起来 配置git个人信息（如果已经配置过了，可以跳过） 12git config --global user.name \"yangchendev\"git config --global user.email \"yangchendev@qq.com\" 生成秘钥 这里是第二个坑，你的电脑可能没有.ssh文件夹，你需要手动创建一个 1mkdir ~/.ssh 再使用 12cd ~/.sshssh-keygen -t rsa -C \"yangchendev@qq.com\" //在这个命令后一直回车就行 生成的id_rsa.pub在如下的目录 用记事本打开id_rsa.pub，把里面的内容全部复制 接下来是在github上添加SSH Key 最后在你的博客根目录下打开_config.yml在其中添加如下信息 repo 后填你刚刚新建的那个仓库地址 哈哈，第三个坑来啦，我们在修改_config.yml时，需要在“：”后添加一个空格再写值，不然会出错 安装hexo-deployer-git自动部署发布工具使用如下命令安装（记得在博客的根目录下打开git bash） 1npm install hexo-deployer-git --save 最后使用三部曲将博客发布到GitHub上 123hexo cleanhexo generatehexo deploy 第一次可能要求你添加GitHub的账号和密码，正常执行的效果如下图所示 上传成功后你可以在仓库中看到你上传的代码 你可以使用 你的GitHub名.github.io 来访问你的博客了，是不是很6啊 我知道你可能不会满足于此我们完全可以使用我们自己的域名来访问自己的博客，这样是不是更高大上了 这里我推荐在阿里云的万网上购买域名（我购买的是.top 比较便宜哈哈），域名购买成功后，你需要为你的域名添加解析 这里要添加三个解析： 第一个的记录值是github为你分配的地址，即你的github名.github.io 第二个和第三个是github服务器的地址，不填的话会无法访问github的啦 当然还有一个操作是为你的仓库设置自定义的域名，这样就可以通过这个域名来访问 你的github名.github.io Hexo 主题Hexo 有很多主题可供我们使用，这里我推荐使用 next主题官网有详细的使用说明，大家看看就会了，我也会推荐一篇教程。 瞅瞅我的博客 参考文档： Git安装及SSH Key管理之Windows篇 Hexo-NexT搭建个人博客 hexo的next主题个性化教程:打造炫酷网站","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]}]}